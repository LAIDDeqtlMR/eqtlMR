

###############################################################
##Convert TwoSampleMR format to MendelianRandomization format##
###############################################################

# The Mendelian Randomization package offers MR methods that can be used with the same data used in the TwoSampleMR package.
# This function converts from the TwoSampleMR format to the MRInput class.
#
# @param dat Output from the [harmonise_data()] function.
# @param get_correlations Default `FALSE`. If `TRUE` then extract the LD matrix for the SNPs from the European 1000 genomes data on the MR-Base server.
# @param pop If `get_correlations` is `TRUE` then use the following 
#
# @export
# @return List of MRInput objects for each exposure/outcome combination

dat2MRInput <- function(dat, get_correlations=FALSE, pop="EUR", bfile=NULL, plink_bin=NULL)
{
  out <- plyr::dlply(dat, c("exposure", "outcome"), function(x)
  {
    x <- plyr::mutate(x)
    message("Converting:")
    message(" - exposure: ", x$exposure[1])
    message(" - outcome: ", x$outcome[1])
    if(get_correlations)
    {message(" - obtaining LD matrix")
      ld <- ieugwasr::ld_matrix(variants=unique(x$SNP), with_alleles=TRUE, pop=pop, bfile=bfile, plink_bin=plink_bin)
      save(ld, file='plink_ld_matrix.RData')
      save(x, file='plink_ld_snps.RData')
      # If all alleles are "T", read.table in R guess it as a logical column
      if( any( grepl( 'TRUE', rownames(ld) ) ) ) {
        colnames(ld) <- rownames(ld) <- sub('TRUE', 'T', rownames(ld))
      }


      # plink reorders the SNPs
      snpnames <- do.call(rbind, strsplit(rownames(ld), split="_"))[,1]
      MD <- match( x$SNP, snpnames )
      ld <- ld[ MD, MD ]
      out <- Harmonize_LD_dat(x, ld)
      if(is.null(out))
      {
        return(NULL)
      }
      x <- out$x
      ld <- out$ld
      if( nrow(x) == 0 ) {
        message( 'Nothing left. Skipping this exposure')
        return(NULL)
      }
      
      MendelianRandomization::mr_input(
        bx = x$beta.exposure,
        bxse = x$se.exposure,
        by = x$beta.outcome,
        byse = x$se.outcome,
        exposure = x$exposure[1],
        outcome = x$outcome[1],
        snps = x$SNP,
        effect_allele=x$effect_allele.exposure,
        other_allele=x$other_allele.exposure,
        eaf = x$eaf.exposure,
        correlation = ld
      )
      
    } else {
      MendelianRandomization::mr_input(
        bx = x$beta.exposure,
        bxse = x$se.exposure,
        by = x$beta.outcome,
        byse = x$se.outcome,
        exposure = x$exposure[1],
        outcome = x$outcome[1],
        snps = x$SNP,
        effect_allele=x$effect_allele.exposure,
        other_allele=x$other_allele.exposure,
        eaf = x$eaf.exposure
      )
    }
  })
  return(out)
}


#Allele harmonization
Harmonise_LD_dat <- function(x, ld) {
  snpnames <- do.call('rbind', strsplit( rownames(ld), split='_' ))
  keep <- ( snpnames[,2] == x$effect_allele.exposure & snpnames[,3] == x$other_allele.exposure ) |
    ( snpnames[,3] == x$effect_allele.exposure & snpnames[,2] == x$other_allele.exposure )
  if( sum(keep) == 0 ) {
    save(ld, file='harmony_ld.RData')
    message(" - none of the SNPs could be aligned to the LD reference panel")
    message("LD matrix dimension ", dim(ld))
    message("LD matrix rownames ", paste( rownames(ld), sep=' ' ))
    message("exposure SNP names ", paste( x$SNP, x$effect_allele.exposure, x$other_allele.exposure, sep='_', collapse=' ' ))
    return(NULL)
  }
  
  if( any( !keep ) ) {
    message(" - the following ", sum(!keep), " SNPs could not be aligned to the LD reference panel:\n- ", paste(snpnames[!keep,1], collapse="\n - "))
    ld <- ld[keep, keep]
    x <- x[keep]
    snpnames <- snpnames[keep,]
  }
  flip <- which( snpnames[,2] != x$effect_allele.exposure )
  x$beta.exposure[flip] <- -x$beta.exposure[flip]
  x$beta.outcome[flip] <- -x$beta.outcome[flip]
  temp <- x$effect_allele.exposure[flip]
  x$effect_allele.exposure[flip] <- x$other_allele.exposure[flip]
  x$other_allele.exposure[flip] <- temp
  return( list( x=x, ld=ld ) )
}


cat results0.2_uncorrel_1* | grep -v '^exposure' | sort -t$'\t' -k 7 -g | less
cat results0.2_correl_1* | grep -v '^exposure' | sort -t$'\t' -k 7 -g | less

cp results0.2_uncorrel_100.txt RES_UNC
cp results0.2_correl_100.txt RES_COR
cp steiger0.2_100.txt STG
cp dat_steiger0.2_100.txt DAT
for I in {101..151}; do echo $I; cat results0.2_uncorrel_${I}.txt | tail -n +2 >> RES_UNC; cat dat_steiger0.2_${I}.txt | tail -n +2 >> DAT; cat steiger0.2_${I}.txt | tail -n +2 >> STG; cat results0.2_correl_${I}.txt | tail -n +2 >> RES_COR; done

##################################
#####      Plotting MR        ####
##################################
library(ggplot2)
library(dplyr)

#input file loading
resUnc <- read.delim("RES_UNC")
head(resUnc)
resCor <- read.delim("RES_COR")
head(resCor)

#create function
pick<-function(gene,res,dat){
res1<-subset(res,exposure==gene)
dat1<-subset(dat,exposure==gene)
res1$id.exposure<-dat1$id.exposure[1]
res1$id.outcome<-dat1$id.outcome[1]
res1$b<-res1$beta
list(res=res1,dat=dat1)}

#data visualization
(one<-pick('JAK2',resCor,dat))
mr_scatter_plot(one$res,one$dat)[[1]]->p1
(single<-mr_singlesnp(one$dat))
p2 <- mr_forest_plot(single)[[1]]
p3 <- mr_funnel_plot(single)[[1]]
print(p1)
print(p2)
print(p3)
pdf('JAK2.pdf')
dev.off()
