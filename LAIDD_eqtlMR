

###############################################################
##Convert TwoSampleMR format to MendelianRandomization format##
###############################################################

# The Mendelian Randomization package offers MR methods that can be used with the same data used in the TwoSampleMR package.
# This function converts from the TwoSampleMR format to the MRInput class.
#
# @param dat Output from the [harmonise_data()] function.
# @param get_correlations Default `FALSE`. If `TRUE` then extract the LD matrix for the SNPs from the European 1000 genomes data on the MR-Base server.
# @param pop If `get_correlations` is `TRUE` then use the following 
#
# @export
# @return List of MRInput objects for each exposure/outcome combination

dat2MRInput <- function(dat, get_correlations=FALSE, pop="EUR", bfile=NULL, plink_bin=NULL)
{
  out <- plyr::dlply(dat, c("exposure", "outcome"), function(x)
  {
    x <- plyr::mutate(x)
    message("Converting:")
    message(" - exposure: ", x$exposure[1])
    message(" - outcome: ", x$outcome[1])
    if(get_correlations)
    {message(" - obtaining LD matrix")
      ld <- ieugwasr::ld_matrix(variants=unique(x$SNP), with_alleles=TRUE, pop=pop, bfile=bfile, plink_bin=plink_bin)
      save(ld, file='plink_ld_matrix.RData')
      save(x, file='plink_ld_snps.RData')
      # If all alleles are "T", read.table in R guess it as a logical column
      if( any( grepl( 'TRUE', rownames(ld) ) ) ) {
        colnames(ld) <- rownames(ld) <- sub('TRUE', 'T', rownames(ld))
      }


      # plink reorders the SNPs
      snpnames <- do.call(rbind, strsplit(rownames(ld), split="_"))[,1]
      MD <- match( x$SNP, snpnames )
      ld <- ld[ MD, MD ]
      out <- Harmonize_LD_dat(x, ld)
      if(is.null(out))
      {
        return(NULL)
      }
      x <- out$x
      ld <- out$ld
      if( nrow(x) == 0 ) {
        message( 'Nothing left. Skipping this exposure')
        return(NULL)
      }
      
      MendelianRandomization::mr_input(
        bx = x$beta.exposure,
        bxse = x$se.exposure,
        by = x$beta.outcome,
        byse = x$se.outcome,
        exposure = x$exposure[1],
        outcome = x$outcome[1],
        snps = x$SNP,
        effect_allele=x$effect_allele.exposure,
        other_allele=x$other_allele.exposure,
        eaf = x$eaf.exposure,
        correlation = ld
      )
      
    } else {
      MendelianRandomization::mr_input(
        bx = x$beta.exposure,
        bxse = x$se.exposure,
        by = x$beta.outcome,
        byse = x$se.outcome,
        exposure = x$exposure[1],
        outcome = x$outcome[1],
        snps = x$SNP,
        effect_allele=x$effect_allele.exposure,
        other_allele=x$other_allele.exposure,
        eaf = x$eaf.exposure
      )
    }
  })
  return(out)
}


#Allele harmonization
Harmonise_LD_dat <- function(x, ld) {
  snpnames <- do.call('rbind', strsplit( rownames(ld), split='_' ))
  keep <- ( snpnames[,2] == x$effect_allele.exposure & snpnames[,3] == x$other_allele.exposure ) |
    ( snpnames[,3] == x$effect_allele.exposure & snpnames[,2] == x$other_allele.exposure )
  if( sum(keep) == 0 ) {
    save(ld, file='harmony_ld.RData')
    message(" - none of the SNPs could be aligned to the LD reference panel")
    message("LD matrix dimension ", dim(ld))
    message("LD matrix rownames ", paste( rownames(ld), sep=' ' ))
    message("exposure SNP names ", paste( x$SNP, x$effect_allele.exposure, x$other_allele.exposure, sep='_', collapse=' ' ))
    return(NULL)
  }
  
  if( any( !keep ) ) {
    message(" - the following ", sum(!keep), " SNPs could not be aligned to the LD reference panel:\n- ", paste(snpnames[!keep,1], collapse="\n - "))
    ld <- ld[keep, keep]
    x <- x[keep]
    snpnames <- snpnames[keep,]
  }
  flip <- which( snpnames[,2] != x$effect_allele.exposure )
  x$beta.exposure[flip] <- -x$beta.exposure[flip]
  x$beta.outcome[flip] <- -x$beta.outcome[flip]
  temp <- x$effect_allele.exposure[flip]
  x$effect_allele.exposure[flip] <- x$other_allele.exposure[flip]
  x$other_allele.exposure[flip] <- temp
  return( list( x=x, ld=ld ) )
}


#!/usr/bin/env Rscript

suppressPackageStartupMessages( {
  library(ieugwasr)
  library(gwasvcf) 
  library(gwasglue)
  library(VariantAnnotation)
  library(dplyr)
  library(TwoSampleMR)
} )
source("/workspace/BY/lupus/dat2MRInput.R")

set_bcftools("/usr/local/bin/bcftools")

eQTLfolder <- '../eqtl_data_eqtlgen'
vcfFile <- 'ebi-a-GCST003156.vcf.gz'
vcfRSidx <- sub('.gz', '.rsidx', vcfFile)

( args <- commandArgs(trailingOnly=TRUE) )
if( length(args) == 0 ) {
  message('START and END(=START) required')
  q()
} else {
  START <- args[1]
  END <- START
  if( length(args) == 2 ) {
    END <- args[2]
  }
}
print( paste( 'Splits ranging from', START, 'to', END ) )
message( paste( 'Splits ranging from', START, 'to', END ) )

for( SPLIT in START:END ) {
  message( paste( 'Processing', SPLIT ) )
  print( paste( 'Processing', SPLIT ) )
  
  EXPOSURES <- read.delim( paste0( eQTLfolder, '/SPLIT/exposures.', SPLIT ), head=F)[,1]
  print( head(EXPOSURES) )
  load( paste( eQTLfolder, 'exposures.RData', sep='/') )
  
  exp1 <- exp0[ exp0$exposure %in% EXPOSURES, ]
  print( head(exp1) )
  
  vcf <- query_gwas( vcfFile, rsid=exp1$SNP, rsidx=vcfRSidx )
  rowRanges(vcf)
  
  out <- gwasvcf_to_TwoSampleMR(vcf, type='outcome')
  dat0 <- harmonise_data( exp1, out )
  print('harmonised')
  dat <- subset( dat0, dat0$mr_keep == TRUE )
  print( head(dat) )
  print( colnames(dat) )
  dat0.2 <- ld_clump_local( data.frame( rsid=dat$SNP, pval=dat$pval.exposure, id=dat$id.exposure ), clump_kb=10000, clump_p=0.99, clump_r2 = 0.2, bfile='../TGZ/EUR', plink_bin='/usr/local/lib/R/site-library/genetics.binaRies/bin/plink' )
  dat0.2 <- subset( dat, dat$SNP %in% dat0.2$rsid )
  print('clumped')
  dat0.2$r.outcome <- get_r_from_lor(dat0.2$beta.outcome, af=dat0.2$eaf.outcome, ncase=33674, ncontrol=449056, prevalence=0.01)
  print( summary(dat0.2$r.outcome) )
  print('got r')
  print( head(dat0.2) )
  
  steiger0.2 <- directionality_test(dat0.2)
  print('direction tested')
  steiger0.2_1 <- subset( steiger0.2, correct_causal_direction == TRUE )
  dat_steiger0.2 <- subset( dat0.2, dat0.2$exposure %in% steiger0.2_1$exposure )
  write.table(steiger0.2, file=paste0('SPLIT/steiger0.2_', SPLIT, '.txt'), col.names=T, row.names=F, sep="\t")
  write.table(dat_steiger0.2, file=paste0('SPLIT/dat_steiger0.2_', SPLIT, '.txt'), col.names=T, row.names=F, sep="\t")
  
  # MR analysis uncorrelated
  
  two_snps_or_less <- as.data.frame( table( dat_steiger0.2$exposure ) )
  dat_steiger0.2_two_snps_or_less <- subset( dat_steiger0.2, dat_steiger0.2$exposure %in% two_snps_or_less$Var1[ which( two_snps_or_less$Freq <=2 ) ] )
  
  mr_mrbase0.2 <- mr( dat_steiger0.2_two_snps_or_less )
  print(paste('mr uncorrelated done', SPLIT))
  if( plyr::empty( mr_mrbase0.2 ) == TRUE ) {
    mr_mrbase0.2_keep <- data.frame()
  } else {
    mr_mrbase0.2_keep <- mr_mrbase0.2[, c('exposure', 'outcome', 'nsnp', 'method', 'b', 'se', 'pval')]
    names( mr_mrbase0.2_keep )[5:7] <- c('beta', 'se', 'p')
    mr_mrbase0.2_keep$clump_thresh <- "0.2"
    all_res <- mr_mrbase0.2_keep
    data_for_qval <- which( all_res$method == 'IVW' | all_res$method == 'Inverse variance weighted' | all_res$method == 'Wald ratio' )
    all_res[data_for_qval, 'fdr_qval'] <- p.adjust(all_res[ data_for_qval, 'p'], method = 'fdr' )
    write.table( all_res, file=paste0('SPLIT/results0.2_uncorrel_', SPLIT, '.txt'), col.names=T, row.names=F, sep="\t", quote=F)
  }
  
  # MR analysis correlated
  dat_steiger_keep <- subset( dat_steiger0.2, dat_steiger0.2$exposure %in% two_snps_or_less$Var1[ which(two_snps_or_less$Freq > 2) ] )
  
  if( plyr::empty( dat_steiger_keep ) == TRUE ) {
    print(paste('No gene in this chunk have > 2 snps available', SPLIT))
  } else {
    unique_exposures0 <- sort( unique( dat_steiger_keep$exposure ) )
    unique_exposures <- unique_exposures0[ !is.na(unique_exposures0) ]
    corr_results <- data.frame()
    corr_egger_intercept <- data.frame()
    
    for( i in 1:length(unique_exposures) ) {
      uei <- unique_exposures[i]
      dat_steiger_keep1 <- subset( dat_steiger_keep, exposure == uei )
      dat2 <- dat2MRInput( dat_steiger_keep1, get_correlation=TRUE, bfile='../TGZ/EUR', plink_bin='/usr/local/lib/R/site-library/genetics.binaRies/bin/plink' )
      save(dat2, file='MRInput.RData')
      if( is.null(dat2[[1]]) ) stop()
      ivw <- MendelianRandomization::mr_ivw( dat2[[1]], correl=TRUE )
      egger <- MendelianRandomization::mr_egger( dat2[[1]], correl=TRUE )
      maxlik <- MendelianRandomization::mr_maxlik( dat2[[1]], correl=TRUE )
      try( temp_data <- rbind( c( ivw@Exposure, ivw@Outcome, ivw@SNPs, ivw@class[1], ivw@Estimate, ivw@StdError, ivw@Pvalue),
                               c( egger@Exposure, egger@Outcome, egger@SNPs, egger@class[1], egger@Estimate, egger@StdError.Est, egger@Pvalue.Est),
                               c( maxlik@Exposure, maxlik@Outcome, maxlik@SNPs, maxlik@class[1], maxlik@Estimate, maxlik@StdError, maxlik@Pvalue)
      ) )
      try( corr_results <- rbind( corr_results, temp_data ) )
      try( temp_data1 <- c( egger@Exposure, egger@Outcome, egger@SNPs, egger@Intercept, egger@CILower.Int, egger@CIUpper.Int, egger@Pvalue.Int, egger@Heter.Stat[1], egger@Heter.Stat[2] ) )
      try( corr_egger_intercept <- rbind( corr_egger_intercept, temp_data1 ) )
    }
    
    print(paste('mr correlated done', SPLIT))
    corr_results1 <- corr_results
    names( corr_results1 ) <- c('exposure', 'outcome', 'nsnp', 'method', 'beta', 'se', 'p')
    corr_results1[, 5:7] <- sapply( corr_results1[, 5:7], function(x) as.numeric(as.character(x)) )
    corr_results1$clump_thresh <- "0.2"
    all_res <- corr_results1
    write.table( all_res, file=paste0('SPLIT/results0.2_correl_', SPLIT, '.txt'), col.names=T, row.names=F, sep="\t", quote=F)
    
    # egger intercept and q values
    corr_egger_intercept1 <- corr_egger_intercept
    names( corr_egger_intercept1 ) <- c('exposure', 'outcome', 'nsnp', 'intercept', 'lower_ci', 'upper_ci', 'pvalue', 'q', 'q_pval')
    corr_egger_intercept1[, 3:9] <- sapply( corr_egger_intercept1[, 3:9], function(x) as.numeric(as.character(x)) )
    cochrans_q <- corr_egger_intercept1
    cochrans_q$nsnp <- as.numeric(as.character(cochrans_q$nsnp))
    cochrans_q$q_df <- cochrans_q$nsnp - 1
    QD <- which( cochrans_q$q >= cochrans_q$q_df )
    cochrans_q[QD,"i2"] <- (cochrans_q[QD,"q"]-cochrans_q[QD,"q_df"])/cochrans_q[QD,"q"]
    cochrans_q[ -QD, "i2" ] <- round(0, digits = 1)
    
    cochrans_q$conf_int <- paste( round( cochrans_q$lower_ci, digits = 4 ),
                                  round( cochrans_q$upper_ci, digits = 4 ), sep = ', ' )
    qc_write_out <- cochrans_q[, c('exposure', 'outcome', 'nsnp', 'intercept', 'conf_int', 'pvalue', 'q', 'q_pval', 'i2') ]
    names(qc_write_out)[4:8] <- c('egger_intercept', 'egger_intercept_95_ci', 'egger_intercept_pvalue', 'cochrans_q', 'cochrans_q_pval')
    
    write.table( qc_write_out, file=paste0('SPLIT/results0.2_egger_cochransq_', SPLIT, '.txt'), col.names=T, row.names=F, sep="\t", quote=F)
  }
  
}

###############################
##visualizing scattered plot ##
###############################
